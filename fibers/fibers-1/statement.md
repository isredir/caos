|                      |       |
|----------------------|-------|
| **Time limit:**      | `4 s` |
| **Real time limit:** | `5 s` |
| **Memory limit:**    | `64M` |


### Problem fibers-1: cxx/concurrency/generator

### ДИСКЛЕЙМЕР

Эта задача покажется вам знакомой. Вам не кажется. Данная задача более дружелюбная и одновременно
усложненная реинкарнация прошлой.

### Файберы. Генераторы.

[Реализуйте](https://gist.github.com/ObjatieGroba/143a06f33a5e9634d560950c6983c929) функции
помеченные TODO так, чтобы тесты прошли.

Ваша задача реализовать файберы - это легковесный поток (нить) выполнения, который работает в рамках
одного процесса и использует общую область памяти с другими потоками (нитями).

Файберы будут сами решать когда им можно уступить выполнение другой нити используя функцию `yield`
(кооперативная многозадачность).

Центральной точкой работы файберов является планировщик (FiberScheduler), позволяющий накапливать
очередь, а также исполняющий накопленные нити по вызову функции `run`.

Так как файберы это независимые друг от друга по исполнению функции - они обязаны иметь свои
собственные колстек и стек.

Файберы должны быть легковесными - их работа не должна вызывать обращения к ОС (поэтому ucontext.h
запрещен).

### Часть 1. Это база.

Action - специально сообщение от файбера к планировщику и обратно для управления последним. (А еще
передачи аргумента, что будет далее.)

Изучите функцию `trampoline` \- это точка входа в нить. Функция принимает единственный аргумент -
указатель на нить, содержащуюся в Context. По завершению нити из функции трамплин переключаемся в
планировщик, сообщая о завершении. Дорабатывать функцию на этом этапе не требуется. (Почему нельзя
сделать return из трамплина?)

Допишите функцию `FiberScheduler::create_context_from_fiber`. Эта функция подготавливает контекст
первого запуска нити. (Не помню, а с чего должен начинаться запуск файбера?) Советую адресом
возврата явно положить `nullptr`, это упростит дебаг в дальнейшем. Для каста `intptr_t` используйте
`reinterpret_cast`.

Action используется для передачи состояния и дополнительных данных (достаточно одного указателя) от
планировщика файберу и обратно. При запуске файбера всегда передаём из шедуллера Start. Если файбер
хочет продолжить выполнение - передает Sched, иначе Stop.

Допишите функцию `Context::switch_context`. Это база. Функция будет содержать ОДНУ вставку (в других
функциях вставки не нужны). Функция переключает текущее исполнение на сохраненное в структуре, а
также пробрасывает сквозь себя action. С помощью этой и только этой функции мы будем переключать
выполнение. `switch_context` должен сохранять все необходимые регистры и при переключении, но в
самой структуре нет необходимости в иных полях кроме представленных. Для переключения eip
рекомендуются инструкции `call *reg` или `ret`. ASM вставка будет состоять из двух логических частей
- до прыжка (первая часть) и после (вторая часть). Когда и как мы оказываемся во второй части (что
предшествует исполнению кода второй части)? Какие
[clobbers](https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html) необходимо прописать? `memory`?
`cc`? Нужна ли инструкция
[mfence](https://www.felixcloutier.com/x86/mfence.html#:~:text=The%20MFENCE%20instruction%20provides%20a,WC%2C%20and%20WT%20memory%20types.)?
Отмечу что action состоит всего из двух полей помещающихся в два регистра, а значит можно передать
action не добавляя ни одной инструкции с помощью output "+r" (лучше с указанием конкретного
регистра).

[Соглашение о вызовах. 6 Register usage. Какие регистры нужно сохранять? Почему можно не думать о
SSE регистрах?](https://www.agner.org/optimize/calling_conventions.pdf)

Допишите функцию `FiberScheduler::run` наивно. Исключения и ревизоры (Watch) пока не потребуются.

На этом этапе у вас начнут проходить первые тесты!

### Часть 2. Yield. Рекурсивный планировщик.

Допишите функцию `FiberScheduler::yield`. А при чём здесь Action::user_data?

Допишите функцию `scheduler_run` так чтобы вызов планировщика в планировщике не приводил к ошибке.
Почему сделана отдельная функция? Почему нельзя просто `scheduler->run()`?

### Часть 3. Исключения.

Исключения - специальный механизм C++. При запуске исключение происходит раскрутка стека до тех пор,
пока мы не встретим `try-except`.

Что будет если бросить исключение внутри файбера?

Допишите функции `trampoline`, `FiberScheduler::run` и `scheduler_run` так, чтобы исключение
выброшенное в нити пробросилось наружу в планировщик.

Исключение - некоторый завершающий этап работы файбера, поэтому для него заведено отдельное поле в
Context.

На этом этапе должны проходить все тесты до `test_recursive_sched_exc` включительно

### Часть 4. Генераторы.

Наша цель - добиться поведения как у [Python](https://wiki.python.org/moin/Generators).

Простая реализация - генератор внутри итератора создаёт внутри новый планировщик и каждый раз
продолжает исполнение контекста до следующей остановки. Обращу внимание, что by design Context
переносим между планировщиками, поэтому можно создавать каждый раз новый планировщик.

Генератор будет принимать некоторую функцию из которой по yield значения передаются в итератор (без
накопления массива значений). Каждое разыменование итератора - новое значение переданное функцией.

Итератор должен знать место остановки - когда функция переданная в генератор завершила исполнение,
поэтому предлагается всегда в итераторе хранить следующее значение `next_`.

Данный класс практически написан за вас - вам остаётся только заполнить пробелы.

Для этого нам помогут ревизоры (a.k.a. инспекторы a.k.a. Watch). Наследники этого класса
[могут](https://gist.github.com/ObjatieGroba/143a06f33a5e9634d560950c6983c929#file-generators-
cpp-L232) подписываться на события перехода текущего потока в планировщик и менять эти события на
своё усмотрение.

Вопрос на понимание - что произойдет в результате выполнения
`create_current_fiber_watch<SomeWatch>(); yield()`?

Допишите функцию `update`. Функция запускает очередную итерацию генератора.

Допишите функцию `GeneratorWatch::operator()` \- ревизор предназначенный для остановки выполнения
функции генератора. Мы его уже привязали к контексту генератора в конструкторе `Iterator`.

Допишите функцию `FiberScheduler::run` вызывая ревизора при наличии.

В тесте test_generator_endless внутри нити не вызовутся деструкторы, отчего может произойти утечка
памяти. Как решить данную проблему?

Допишите функцию `FiberScheduler::yield` функция должна выбрасывать исключение если оно передано.
Передавайте исключение в деструкторе Итератора.

### Полезное.

Тесты в тестирующей системе не отличаются.

Для использования меток внутри inline asm [ссылка](https://stackoverflow.com/a/16095781).

Ваш код будет скомпилирован с флагами`-Wall -Werror -Wa,--fatal-warnings -O2 -g -m32 -std=c++17`

Для MacOS на ARM процессорах не забудьте добавить флаг компиляции `-arch x86_64`

Valgrind поможет отловить невалидные обращения к памяти.

В качестве ответа необходимо прислать только реализации функций
[с](https://gist.github.com/ObjatieGroba/143a06f33a5e9634d560950c6983c929#file-generators-cpp-L200)
[по](https://gist.github.com/ObjatieGroba/143a06f33a5e9634d560950c6983c929#file-generators-
cpp-L348):

    
    
        template <class Result>
        class Generator;
    
        Action Context::switch_context(Action action);
        void trampoline(Fiber *fiber);
        void scheduler_run(FiberScheduler &sched);
        Context FiberScheduler::create_context_from_fiber(Fiber fiber);
        void *FiberScheduler::yield(void *data);
        void FiberScheduler::run();
                

