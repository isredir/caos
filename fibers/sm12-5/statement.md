|                      |       |
|----------------------|-------|
| **Time limit:**      | `1 s` |
| **Real time limit:** | `5 s` |
| **Memory limit:**    | `64M` |


### Problem sm12-5: cxx/concurrency/fibers

[Реализуйте](https://gist.github.com/ObjatieGroba/f197c54e2f7aa54ecb4d582e3dacf784) функции
помеченные TODO так, чтобы тесты прошли.

Ваша задача реализовать файберы - это легковесный поток (нить) выполнения, который работает в рамках
одного процесса и использует общую область памяти с другими потоками (нитями).

Файберы будут сами решать когда им можно уступить выполнение другой нити используя функцию `yield`
(кооперативная многозадачность).

Центральной точкой работы файберов является планировщик (FiberScheduler), позволяющий накапливать
очередь, а также исполняющий накопленные нити по вызову функции `run`.

Так как файберы это независимые друг от друга по исполнению функции - они обязаны иметь свои
собственные колстек и стек.

Action - специально сообщение от файбера к планировщику и обратно для управления последним. (А еще
передачи аргумента, что будет далее.)

Изучите функцию `run_fiber` \- это точка входа в нить (трамплин). Функция принимает единственный
аргумент - FiberKeeper. По завершению нити из функции трамплин переключаемся в планировщик, сообщая
о завершении. (Почему нельзя сделать return из трамплина?)

Напишите функцию `switch_context`. Функция будет содержать ОДНУ вставку (в других функциях вставки
не нужны). Функция переключает текущее исполнение на сохраненное в структуре. С помощью этой и
только этой функции мы будем переключать выполнение. `switch_context` должен сохранять все
необходимые регистры и при переключении, но в самой структуре нет необходимости в иных полях кроме
представленных. Для переключения eip рекомендуются инструкции `call *reg` или `ret`. ASM вставка
будет состоять из двух логических частей - до прыжка (первая часть) и после (вторая часть). Когда и
как мы оказываемся во второй части (что предшествует исполнению кода второй части)? Какие
[clobbers](https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html) необходимо прописать? `memory`?
`cc`? Нужна ли инструкция
[mfence](https://www.felixcloutier.com/x86/mfence.html#:~:text=The%20MFENCE%20instruction%20provides%20a,WC%2C%20and%20WT%20memory%20types.)
с учетом, что на самом деле мы все исполняем линейно в одном и том же потоке?

Yield переключает выполнение на другую нить если такая нить существует.

FiberKeeper (std::function) содержит нетривиальный конструктор и деструктор. Используйте memcpy и
memset, чтобы избежать двойного вызова деструктора и передать аргумент внутрь файбера.
Альтернативным решением может стать конструирование FiberKeeper через new по указателю (не на куче).

Метод switch_context меняет местами текущее исполнение и "сохраненное" в структуре.

[Соглашение о вызовах. 6 Register usage. SSE регистры можно
портить!](https://www.agner.org/optimize/calling_conventions.pdf)

Обратите внимание, что run_fiber принимает на самом деле (по C++ decl) указатель на fiber, а не саму
структуру. Тем не менее советую положить структуру рядом - до указателя.

Тесты и функция main в тестирующей системе не отличаются кроме теста `test_secret`, тело которого
вам неизвестно.

Для использования меток внутри inline asm [ссылка](https://stackoverflow.com/a/16095781).

Обратите внимание на InlineScheduler запускающий файберы незамедлительно. Этот планировщик проходит
несколько тестов.

Ваш код будет скомпилирован с флагом `-O2`

Для MacOS на ARM процессорах не забудьте добавить флаг компиляции `-arch x86_64`

В качестве ответа необходимо прислать только реализации функций:

    
    
    void FiberScheduler::Context::switch_context() {
        ...
    }
    
    void FiberScheduler::schedule(Fiber fiber) {
        ...
    }
    
    void FiberScheduler::yield() {
        ...
    }
    
    void FiberScheduler::run() {
        ...
    }
        

