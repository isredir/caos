|                      |       |
|----------------------|-------|
| **Time limit:**      | `2 s` |
| **Real time limit:** | `5 s` |
| **Memory limit:**    | `64M` |


### Problem sm08-2: unix/files/read-file-fd-1

Напишите функцию

    
    
    struct FileContent
    {
        ssize_t size;
        char *data;
    };
    struct FileContent read_file(int fd);

Функция должна считать все содержимое файла по переданному файловому дескриптору. В случае ошибки
чтения поле `size` должно быть равно -1, а поле `data` — NULL. В случае успешного чтения поле `size`
должно содержать размер считанного файла, поле `data` — указатель на считанные данные. Область
памяти `data` должна быть на 1 больше размера файла, и последний байт в области должен содержать
байт 0. Таким образом, текстовый файл в памяти будет хранится как строка (null-terminated string).

Ситуация нехватки памяти должна обрабатываться. В этом случае возвращаемое значение такое же, как
при ошибке чтения.

Для буферизации ввода используйте локальный буфер размера 4096 байт. **Размер первой аллокации
должен быть не больше 4096 байтов, для больших размеров не гарантируется корректная работа тестов.**

Используйте POSIX API работы с файлами.

Размер потребляемой памяти не должен превышать `max(4096, 2 * размер_файла)`.

Помните, что `read` не обязан всегда считывать ровно то количество байт, которое было запрошено.

Гарантируется, что в тестах размер файлов, которые должны быть успешно обработаны, не превышает 10M.

При сдаче программы подключите заголовочный файл [`read_file.h`](https://caos.myltsev.ru/cgi-
bin/new-client?SID=2633f3fd3d7825db&prob_id=61&action=194&file=read_file.h).

