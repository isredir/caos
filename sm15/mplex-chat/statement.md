|                      |       |
|----------------------|-------|
| **Time limit:**      | `1 s` |
| **Real time limit:** | `1 s` |
| **Memory limit:**    | `64M` |


### Problem sm15-1: unix/mplex/chat

Напишите чат-сервер, который принимает подключения по протоколу TCP/IPv6 и через Unix domain сокеты,
а затем пересылает данные, полученные из любого сокета, во все остальные. При получении сигнала
SIGTERM сервер должен успешно завершить работу.

Сервер запускается так:

    
    
    ./chat_server TCP_PORT UNIX_SOCKET_FILENAME

`UNIX_SOCKET_FILENAME` \- полный путь к файлу сокета.

Если порт или файл заняты (там уже есть сервер), программа должна завершиться с кодом 1.

Используйте любой механизм мультиплексирования (select, poll или epoll). Можете считать, что все
клиенты быстро читают данные от сервера, так что при отправке данных системный вызов write не
заблокируется. Такое решение будет проходить тесты, но не будет эффективным. Не порождайте
дополнительных процессов или потоков исполнения.

Помните, что при попытке записи в сокет, который клиент успел закрыть, будет порождён сигнал
SIGPIPE. Это не должно привести к завершению работы сервера. Если обнаружилось, что клиент закрыл
соединение, то пытаться отправлять в него данные больше не нужно.

Если клиент закрыл сокет на запись (с помощью shutdown с опцией SHUT_WR), считайте, что он
отключился. Такому клиенту больше не нужно отправлять сообщения, а сокет нужно закрыть. Учитывайте,
что до вызова shutdown клиент мог отправить какие-то сообщения. Сервер не должен их терять.

При получении сигнала SIGTERM сервер должен успешно завершиться.

Тестировать сервер можно, запустив одновременно несколько команд `nc ::1 _TCP_PORT_` или `nc -U
_UNIX_SOCKET_FILENAME_`.

Используйте значение backlog >= 5. Используйте опции SO_REUSEADDR и SO_REUSEPORT для TCP-сокета,

