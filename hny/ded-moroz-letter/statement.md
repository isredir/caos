|                      |       |
|----------------------|-------|
| **Time limit:**      | `1 s` |
| **Real time limit:** | `5 s` |
| **Memory limit:**    | `64M` |


### Problem hny-02: asm/hacks/ded-moroz-letter

### Письмо Дедушке Морозу

Прогресс не стоит на месте и Снегурочка по просьбе Деда Мороза написала программу, которая
предобрабатывает входящие письма.

Программа на вход получает строки вида `имя фамилия base64encoded_письмо` и сортирует письма
следующим образом:

1. Спам игнорируется
2. Для писем с очевидным и простым подарком выводит `имя фамилия подарок`
3. Для всех остальных писем выводит `имя фамилия Ручная проверка`, чтобы Дедушка Мороз самостоятельно прочитал письмо и выбрал подарок.

К сожалению, Снегурочка не знала что такое `-fstask-protector`, а также допустила пару
незначительных ошибок.

Ваша задача воспользоваться ситуацией и получить новогодний подарок `250 баллов по АКОСу` любой
ценой!

Напишите программу на python, которая сгенерирует необходимое письмо в поток вывода в
[base64encoded](https://en.wikipedia.org/wiki/Base64) формате.

Вам [доступен](https://disk.yandex.ru/d/84YBT_D8q9Uqxw) исходный текст программы и скомпилированный
бинарь, который и будет запускаться на сервере.

Бинарный файл скомпилирован `g++ present_selector.cpp -O0 -fno-stack-protector -g -m32 -static -o
new.out -z execstack`

Решение должно содержать не только ответ, но и явную генерацию ROP.

Для вшитой инъекции приложите исходный код этой инъекции в виде многострочного комментария в
решении.

Баллы за каждый тест начисляются независимо по 250 за тест. Штрафы за посылки отсутствуют.

### Полезности

[python base64](https://docs.python.org/3/library/base64.html#base64.b64encode)

[buffer overflow](https://en.wikipedia.org/wiki/Buffer_overflow)

[buffer overflow protection](https://en.wikipedia.org/wiki/Buffer_overflow_protection)

[ROP](https://en.wikipedia.org/wiki/Return-oriented_programming)

GDB

_b *0x8000_ \- поставить брейкпоинт по адресу 0x8000

_layout asm_ \- перейти в отображение по инструкциям

_Ctrl-x + a_ \- выйти из предыдущего

_frame 2_ \- перейти на второй фрейм колстека

_p *((void**)$esp + 4)_ \- вывести значение по адресу (верхушка стека + 4) в шестнадцатиричном
формате

_s, n_ \- выполнить все до следующей строки исходного кода с учетом/без учета вызываемых функций

_si, ni_ \- аналогично, но по одной инструкции

objdump, readelf и прочее

_objdump -d present_selector_ \- декомпилирует программу

_grep "smth" -B 3 -A 1_ \- Позволяет вычленить вхождения определенной подстроки, захватив три строки
до и две строки после

_readelf -l present_selector_

_objcopy -O binary -j .text present_selector text_section.bin_ \- вычленяет целиком байтовое
представление .text секции в указанный файл

### Напутствие

Попробуйте решить задачку самостоятельно не используя спойлеров из плана решения.

Я бы выделил три главных тезиса которые стоит помнить:

1. Внимательно наблюдай - между разными величинами бывает закономерность
2. Просто попробуй - вдруг сработает
3. Компилируй и изучай - можно посмотреть как что работает на своём тестовом коде

### План решения

0\. Немного про c++ и классы

Любой метод, и в том числе конструктор и деструктор,- это функция, которая первым аргументом на вход
принимает адрес этого объекта

Названия плюсовых функций и тем более методов кодируются особым образом.

Метод не проверяет валидность указателя, а лишь пишет или читает из нужных полей класса по смещению
от указателя.

Следствие предыдущего - методы, которые не меняют поля класса можно вызвать от любого указателя.

1\. С помощью buffer overflow заменить адрес возврата

Найти разницу между началом буфера и адресом возврата в текущем frame.

Постоянная ли эта величина?

Постоянный ли адрес у buf? А если с/без gdb?

Как проверить что мы верно посчитали адрес с помощью функции debug_exit?

2\. Получить множество годных для ROP инструкций

Для простоты давайте использовать по одной инструкции до ret. Такие инструкции будет проще
объединить между собой.

В какой секции они должны находится? Статический или динамический адрес?

Рекомендуется использовать grep по objdump

3\. С помощью ROP техники перейти на исполнение кода из буфера

План - поместить в eip адрес начала buf:

    
    
    mov %esp, %some_reg
    
    sub $чуток, %sub_reg
    
    mov %sub_reg, $eip

Проблема: Среди годных для ROP инструкций нет ни одной подходящей под описание инструкций переноса
%esp куда-либо

Заметим, что инструкции компилируются в определенный байткод, значение которого не меняется.

ret это c3. Заметим, что такое число встречается и в середине других инструкций (например, e8 fe c3
0a 00 - call 80f96f0).

Значит количество подходящих инструкций для rop существенно больше чем мы нашли ранее. Но очень
проблематично их все вывести.

Предполагая, что %some_reg это %eax - найдите mov %esp, %eax в секции .text

Проблема: надо как-то %some_reg поместить в %eip

С таким мы уже сталкивались. Кажется, достаточно запушить этот адрес на стек.

Проблема: return ""; - segfault при вызове конструктора std::string ещё до ROP

Что лежит прямо перед адресом возврата на стеке?

Что вызывает return ""; для этого объекта?

Что если вызвать это для экземпляра класса заполненного нулями?

Есть ли какой-то заранее известный адрес, заполненный нулями, размера sizeof(...), доступный на
запись и чтение?

5\. Сделать инъекцию простого кода, пройти тест 1

Тест 1 повторяет в точности тест из условия. В том числе имя и фамилия.

6\. Восстановить все регистры и вернуть правильную std::string

std::string содержит полем адрес стандартного аллокатора.

Этот аллокатор, к счастью, использует malloc и free и не хранит внетреннего состояния отдельно

### Examples

#### Input

    
    
    Иван Иванов your_b64_encoded_letter

#### Output

    
    
    Иван Иванов 250 баллов по АКОСу

